'use client'
import { defaultMarkdownParser, defaultMarkdownSerializer, MarkdownSerializer } from '@tiptap/pm/markdown'

// 1. Clone + extend the default node serializersâ€¦
const nodes = {
  ...defaultMarkdownSerializer.nodes,

  // Tiptap's hardBreak node â†’ CommonMark line break
  hardBreak: defaultMarkdownSerializer.nodes.hard_break,

  // Lists
  bulletList:   defaultMarkdownSerializer.nodes.bullet_list,
  orderedList:  defaultMarkdownSerializer.nodes.ordered_list,
  listItem:     defaultMarkdownSerializer.nodes.list_item,

  // Blockquotes, headings, code blocks, horizontal rules, etc.
  blockquote:     defaultMarkdownSerializer.nodes.blockquote,
  heading:        defaultMarkdownSerializer.nodes.heading,
  codeBlock:      defaultMarkdownSerializer.nodes.fence,
  horizontalRule: defaultMarkdownSerializer.nodes.horizontal_rule,
}

// 2. Clone + extend the default mark serializersâ€¦
const marks = {
  ...defaultMarkdownSerializer.marks,

  // **bold**
  bold: defaultMarkdownSerializer.marks.strong,

  // _italic_
  italic: defaultMarkdownSerializer.marks.em,

  // ~~strikethrough~~
  strikethrough: defaultMarkdownSerializer.marks.strike,

  // `inline code`
  code: defaultMarkdownSerializer.marks.code,

  // [link](url)
  link: defaultMarkdownSerializer.marks.link,

  // <u>underline</u> (CommonMark has no native, so we emit HTML)
  underline: {
    open: '<u>',
    close: '</u>',
    mixable: true,
    expelEnclosingWhitespace: true,
  },
}

// 3. Build your custom serializer
const customMarkdownSerializer = new MarkdownSerializer(nodes, marks)

import { Box, Button, Popover } from "@mui/material";
import Placeholder from "@tiptap/extension-placeholder";
import { EditorContent, useEditor } from "@tiptap/react";
import Document from "@tiptap/extension-document";
import Text from "@tiptap/extension-text";
import Paragraph from "@tiptap/extension-paragraph";
import HardBreak from "@tiptap/extension-hard-break";
import { useEffect, useRef, useState } from "react";
import "./editor.css";
import { CombinedHighlighting } from "./extentions";

function UserInputBox({
  wordLimit = 300,
  setUserInput,
  userInput = "",
  frozenWords,
  frozenPhrases,
  user,
}) {
  const [anchorEl, setAnchorEl] = useState(null);
  const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });
  const [selectedWord, setSelectedWord] = useState("");
  const [editorKey, setEditorKey] = useState(0); // Force editor recreation
  const isInternalUpdate = useRef(false);

  const editor = useEditor({
    extensions: [
      Document.extend({
        content: 'textblock'
      }),
      Paragraph.extend({
        name: 'textblock',
        content: 'inline*',
        parseHTML() {
          return [{ tag: 'div' }]
        },
        renderHTML() {
          return ['div', { style: 'white-space: pre-wrap;  line-height: 1.5; margin: 0; padding: 0;' }, 0]
        }
      }),
      Text,
      HardBreak.configure({
        keepMarks: false,
      }),
      Placeholder.configure({ placeholder: "Enter your text here..." }),
      CombinedHighlighting.configure({
        limit: wordLimit,
        frozenWords: frozenWords.set,
        frozenPhrases: frozenPhrases.set,
      }),
    ],
    content: userInput,
    immediatelyRender: false,
    editorProps: {
      attributes: {
        style: 'white-space: pre-wrap; font-family: monospace; line-height: 1.5;'
      },
      handleKeyDown: (view, event) => {
        if (event.key === 'Enter') {
          // Always insert a hard break (line break) instead of creating new paragraphs
          const { tr } = view.state;
          view.dispatch(tr.replaceSelectionWith(view.state.schema.nodes.hardBreak.create()));
          return true;
        }
        return false;
      }
    },
    onSelectionUpdate: ({ editor }) => {
      const { from, to } = editor.state.selection;
      const selectedText = editor.state.doc.textBetween(from, to, " ").trim();

      if (selectedText && from !== to) {
        setSelectedWord(selectedText);

        setTimeout(() => {
          const { view } = editor;
          const start = view.coordsAtPos(from);

          setPopoverPosition({
            top: start.bottom + window.scrollY,
            left: start.left + window.scrollX,
          });

          setAnchorEl(document.body);
        }, 10);
      } else {
        clearSelection();
      }
    },
    onUpdate: ({ editor }) => {
      isInternalUpdate.current = true;
      // Get the raw text content, preserving line breaks
      const htmlContent = editor.getHTML();
      // Convert <br> tags back to newlines for plain text
      const textContent = htmlContent
        .replace(/<div[^>]*>/g, '')
        .replace(/<\/div>/g, '')
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<[^>]*>/g, ''); // Remove any other HTML tags
      
      console.log('ðŸ“¥ raw text content:', JSON.stringify(textContent));
      setUserInput(textContent);
    },
  }, [editorKey]); // Recreate editor when key changes

  const clearSelection = () => {
    setAnchorEl(null);
    setSelectedWord("");
  };

  useEffect(() => {
    return () => editor?.destroy();
  }, [editor]);

  useEffect(() => {
    if (!editor || isInternalUpdate.current) {
      // clear the flag so that onUpdate can fire next time
      isInternalUpdate.current = false
      return
    }

    // Convert newlines to HTML breaks and set as content
    const htmlContent = userInput.replace(/\n/g, '<br>');
    const currentHtml = editor.getHTML().replace(/<div[^>]*>/g, '').replace(/<\/div>/g, '');
    
    if (currentHtml !== `<div style="white-space: pre-wrap; font-family: monospace; line-height: 1.5; margin: 0; padding: 0;">${htmlContent}</div>`) {
      editor.commands.setContent(`<div style="white-space: pre-wrap; font-family: monospace; line-height: 1.5; margin: 0; padding: 0;">${htmlContent}</div>`);
    }

    // we're done syncing, clear the flag again
    isInternalUpdate.current = false
  }, [userInput, editor])

  // Force editor recreation when frozen words/phrases change
  useEffect(() => {
    setEditorKey(prev => prev + 1);
  }, [frozenWords.set, frozenPhrases.set]);

  const normalize = (text) => text.toLowerCase().trim();
  const handleToggleFreeze = () => {
    const key = normalize(selectedWord);
    const isPhrase = key.includes(" ");

    if (isPhrase) {
      frozenPhrases.toggle(key);
    } else {
      frozenWords.toggle(key);
    }
    clearSelection();
  };

  const isFrozen = () => {
    const raw = selectedWord.trim().toLowerCase();
    const unquoted = raw.replace(/^"+|"+$/g, "");

    // Check both quoted and unquoted keys
    return frozenPhrases.has(raw) || frozenPhrases.has(`"${unquoted}"`) || frozenPhrases.has(unquoted)
      || frozenWords.has(raw) || frozenWords.has(unquoted);
  };

  if (!editor) return null;

  const paidUser =
    user?.package === "pro_plan" ||
    user?.package === "value_plan" ||
    user?.package === "unlimited";

  const getButtonText = () =>
    !paidUser
      ? "Please upgrade to Freeze"
      : isFrozen()
      ? "Unfreeze"
      : "Freeze";

  return (
    <Box
      sx={{
        flexGrow: 1,
        cursor: "text",
        position: "relative",
        overflowY: "auto",
      }}
    >
      <EditorContent editor={editor} />

      <Popover
        open={Boolean(anchorEl)}
        anchorEl={anchorEl}
        onClose={clearSelection}
        anchorReference="anchorPosition"
        anchorPosition={popoverPosition}
        transformOrigin={{ vertical: "top", horizontal: "left" }}
      >
        <Button
          variant="contained"
          size="small"
          disabled={!paidUser}
          onClick={handleToggleFreeze}
        >
          {getButtonText()}
        </Button>
      </Popover>
    </Box>
  );
}

export default UserInputBox;
