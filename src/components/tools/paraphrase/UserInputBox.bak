'use client'
import { defaultMarkdownParser, defaultMarkdownSerializer, MarkdownSerializer } from '@tiptap/pm/markdown'

// 1. Clone + extend the default node serializersâ€¦
const nodes = {
  ...defaultMarkdownSerializer.nodes,

  // Tiptapâ€™s hardBreak node â†’ CommonMark line break
  hardBreak: defaultMarkdownSerializer.nodes.hard_break,

  // Lists
  bulletList:   defaultMarkdownSerializer.nodes.bullet_list,
  orderedList:  defaultMarkdownSerializer.nodes.ordered_list,
  listItem:     defaultMarkdownSerializer.nodes.list_item,

  // Blockquotes, headings, code blocks, horizontal rules, etc.
  blockquote:     defaultMarkdownSerializer.nodes.blockquote,
  heading:        defaultMarkdownSerializer.nodes.heading,
  codeBlock:      defaultMarkdownSerializer.nodes.fence,
  horizontalRule: defaultMarkdownSerializer.nodes.horizontal_rule,
}

// 2. Clone + extend the default mark serializersâ€¦
const marks = {
  ...defaultMarkdownSerializer.marks,

  // **bold**
  bold: defaultMarkdownSerializer.marks.strong,

  // _italic_
  italic: defaultMarkdownSerializer.marks.em,

  // ~~strikethrough~~
  strikethrough: defaultMarkdownSerializer.marks.strike,

  // `inline code`
  code: defaultMarkdownSerializer.marks.code,

  // [link](url)
  link: defaultMarkdownSerializer.marks.link,

  // <u>underline</u> (CommonMark has no native, so we emit HTML)
  underline: {
    open: '<u>',
    close: '</u>',
    mixable: true,
    expelEnclosingWhitespace: true,
  },
}

// 3. Build your custom serializer
const customMarkdownSerializer = new MarkdownSerializer(nodes, marks)

import { Box, Button, Popover } from "@mui/material";
import Placeholder from "@tiptap/extension-placeholder";
import { EditorContent, useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { useEffect, useRef, useState } from "react";
import "./editor.css";
import { CombinedHighlighting } from "./extentions";

function UserInputBox({
  wordLimit = 300,
  setUserInput,
  userInput = "",
  frozenWords,
  frozenPhrases,
  user,
}) {
  const [anchorEl, setAnchorEl] = useState(null);
  const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });
  const [selectedWord, setSelectedWord] = useState("");
  const [editorKey, setEditorKey] = useState(0); // Force editor recreation
  const isInternalUpdate = useRef(false);
  const [initialDoc,setInitialDoc]= useState(userInput
    ? defaultMarkdownParser.parse(userInput).toJSON()
    : undefined)
  const editor = useEditor({
    extensions: [
      StarterKit,
      Placeholder.configure({ placeholder: "Enter your text here..." }),
      CombinedHighlighting.configure({
        limit: wordLimit,
        frozenWords: frozenWords.set,
        frozenPhrases: frozenPhrases.set,
      }),
    ],
    content: userInput,
    // content: initialDoc,
    immediatelyRender: false,
    onSelectionUpdate: ({ editor }) => {
      const { from, to } = editor.state.selection;
      const selectedText = editor.state.doc.textBetween(from, to, " ").trim();

      if (selectedText && from !== to) {
        setSelectedWord(selectedText);

        setTimeout(() => {
          const { view } = editor;
          const start = view.coordsAtPos(from);

          setPopoverPosition({
            top: start.bottom + window.scrollY,
            left: start.left + window.scrollX,
          });

          setAnchorEl(document.body);
        }, 10);
      } else {
        clearSelection();
      }
    },
    onUpdate: ({ editor }) => {
      isInternalUpdate.current = true;
      const md = customMarkdownSerializer.serialize(editor.state.doc);
      console.log('ðŸ“¥ serialized Markdown:', JSON.stringify(md));
      setUserInput(md);
    },
  }, [editorKey]); // Recreate editor when key changes

  const clearSelection = () => {
    setAnchorEl(null);
    setSelectedWord("");
  };

  useEffect(() => {
    return () => editor?.destroy();
  }, [editor]);


useEffect(() => {
  if (!editor || isInternalUpdate.current) {
    // clear the flag so that onUpdate can fire next time
    isInternalUpdate.current = false
    return
  }

  // parse the Markdown into a ProseMirror node
  const doc = defaultMarkdownParser.parse(userInput)

  // update the editor with that JSON
  editor.commands.setContent(doc.toJSON())

  // weâ€™re done syncing, clear the flag again
  isInternalUpdate.current = false
}, [userInput, editor])
  // useEffect(() => {
  //   if (editor && !isInternalUpdate.current && userInput !== JSON.stringify(customMarkdownSerializer.serialize(editor.state.doc))) {
  //     // editor.commands.setContent(userInput);
  //     setInitialDoc(userInput
  //       ? defaultMarkdownParser.parse(userInput).toJSON()
  //       : undefined)
  //   }
  //   isInternalUpdate.current = false;
  // }, [userInput, editor]);

  // Force editor recreation when frozen words/phrases change
  useEffect(() => {
    setEditorKey(prev => prev + 1);
  }, [frozenWords.set, frozenPhrases.set]);

  const normalize = (text) => text.toLowerCase().trim();
  const handleToggleFreeze = () => {
    const key = normalize(selectedWord);
    const isPhrase = key.includes(" ");

    if (isPhrase) {
      frozenPhrases.toggle(key);
    } else {
      frozenWords.toggle(key);
    }
    clearSelection();
  };

  // const normalize = (text) => text.toLowerCase().trim().replace(/^"+|"+$/g, '');
  // const isFrozen = () => {
  //   console.log(frozenPhrases, selectedWord)
  //   const key = normalize(selectedWord);
  //   return key.includes(" ")
  //     ? frozenPhrases.has(key)
  //     : frozenWords.has(key);
  // };

const isFrozen = () => {
  const raw = selectedWord.trim().toLowerCase();
  const unquoted = raw.replace(/^"+|"+$/g, "");

  // Check both quoted and unquoted keys
  return frozenPhrases.has(raw) || frozenPhrases.has(`"${unquoted}"`) || frozenPhrases.has(unquoted)
    || frozenWords.has(raw) || frozenWords.has(unquoted);
};
  if (!editor) return null;

  const paidUser =
    user?.package === "pro_plan" ||
    user?.package === "value_plan" ||
    user?.package === "unlimited";

  const getButtonText = () =>
    !paidUser
      ? "Please upgrade to Freeze"
      : isFrozen()
      ? "Unfreeze"
      : "Freeze";

  return (
    <Box
      sx={{
        flexGrow: 1,
        cursor: "text",
        position: "relative",
        overflowY: "auto",
      }}
    >
      <EditorContent editor={editor} />

      <Popover
        open={Boolean(anchorEl)}
        anchorEl={anchorEl}
        onClose={clearSelection}
        anchorReference="anchorPosition"
        anchorPosition={popoverPosition}
        transformOrigin={{ vertical: "top", horizontal: "left" }}
      >
        <Button
          variant="contained"
          size="small"
          disabled={!paidUser}
          onClick={handleToggleFreeze}
        >
          {getButtonText()}
        </Button>
      </Popover>
    </Box>
  );
}

export default UserInputBox;
