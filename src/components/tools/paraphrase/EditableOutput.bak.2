
// src/components/tools/paraphrase/EditableOutput.jsx
"use client"

import React, { useEffect } from "react"
import { Node, Extension } from "@tiptap/core"
import { Decoration, DecorationSet } from "@tiptap/pm/view"
import { Plugin, TextSelection } from "prosemirror-state"
import { EditorContent, useEditor } from "@tiptap/react"
import StarterKit from "@tiptap/starter-kit"
import { defaultMarkdownParser } from "@tiptap/pm/markdown"

// ─── 1. Color helper ───────────────────────────────────────────────────────
function getColorStyle(type, dark = false) {
  const adjVerb = dark ? "#ef5c47" : "#d95645"
  const noun    = dark ? "#b6bdbd" : "#530a78"
  const phrase  = dark ? "#b6bdbd" : "#051780"
  const freeze  = "#006ACC"

  if (/NP/.test(type))      return adjVerb
  if (/VP/.test(type))      return noun
  if (/PP|CP|AdvP|AdjP/.test(type)) return phrase
  if (/freeze/.test(type))  return freeze
  return "inherit"
}

// ─── 2. CursorWatcher extension ────────────────────────────────────────────
const CursorWatcher = Extension.create({
  name: "cursorWatcher",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          decorations(state) {
            const { from, empty } = state.selection
            if (!empty) return null

            const decos = []
            state.doc.descendants((node, pos) => {
              if (node.type.name === "sentenceNode") {
                const start = pos
                const end   = pos + node.nodeSize
                if (from >= start && from <= end) {
                  decos.push(Decoration.node(start, end, {
                    class: "active-sentence",
                  }))
                }
              }
            })
            return DecorationSet.create(state.doc, decos)
          },
        },
      }),
    ]
  },
})

// ─── 3. WordNode & SentenceNode ───────────────────────────────────────────
const WordNode = Node.create({
  name: "wordNode",
  group: "inline",
  inline: true,
  content: "text*",
  addAttributes() {
    return {
      "data-sentence-index": { default: null },
      "data-word-index":     { default: null },
      "data-type":           { default: null },
      class:                 { default: "word-span" },
      style:                 { default: null },
    }
  },
  parseHTML() {
    return [{ tag: "span.word-span" }]
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", HTMLAttributes, 0]
  },
})

const SentenceNode = Node.create({
  name: "sentenceNode",
  group: "inline",
  inline: true,
  content: "wordNode*",
  addAttributes() {
    return {
      "data-sentence-index": { default: null },
      class:                 { default: "sentence-span" },
    }
  },
  parseHTML() {
    return [{ tag: "span.sentence-span" }]
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", HTMLAttributes, 0]
  },
})

// ─── 4. EnterHandler extension ─────────────────────────────────────────────
const EnterHandler = Extension.create({
  name: "enterHandler",
  addKeyboardShortcuts() {
    return {
      Enter: ({ editor }) => {
        const { state, view } = editor
        const { tr, selection, doc, schema } = state
        const from = selection.from

        // find max existing sentence index
        let maxIndex = 0
        doc.descendants(node => {
          if (node.type.name === "sentenceNode") {
            const idx = parseInt(node.attrs["data-sentence-index"], 10)
            if (!isNaN(idx) && idx > maxIndex) maxIndex = idx
          }
        })
        const nextIndex = maxIndex + 1

        // build a single-word sentenceNode
        const wordNode = schema.nodes.wordNode.create(
          {
            "data-sentence-index": nextIndex,
            "data-word-index":     1,
            "data-type":           "",
            class:                 "word-span",
            style:                 "color:inherit;cursor:pointer",
          },
          schema.text("\u00A0")
        )
        const sentenceNode = schema.nodes.sentenceNode.create(
          { "data-sentence-index": nextIndex, class: "sentence-span" },
          [wordNode]
        )
        const paragraph = schema.nodes.paragraph.create({}, [sentenceNode])
        const newTr = tr.insert(from, paragraph)

        // move cursor inside new word
        const resolved = newTr.doc.resolve(from + paragraph.nodeSize - 1)
        const sel = TextSelection.near(resolved)
        view.dispatch(newTr.setSelection(sel).scrollIntoView())
        return true
      },
    }
  },
})

// ─── 5. formatContent: JSON ⇄ ProseMirror document ─────────────────────────
function formatContent(data) {
  // empty
  if (!data) {
    return { type: "doc", content: [] }
  }

  // Markdown string?
  if (typeof data === "string") {
    return defaultMarkdownParser.parse(data).toJSON()
  }

  // assume `data` is Array< Array<WordObj> >
  const sentences = Array.isArray(data[0]) ? data : [data]

  const sentenceNodes = sentences.map((sent, sIdx) => ({
    type: "sentenceNode",
    attrs: {
      "data-sentence-index": sIdx + 1,
      class:                 "sentence-span",
    },
    content: sent.map((wObj, wIdx) => {
      const raw = wObj.word
      // detect *italic* markers
      const m = raw.match(/^\*(.+)\*$/)
      const txt = m ? m[1] : raw
      const marks = m ? [{ type: "italic", attrs: {} }] : []
      // spacing logic
      const prefix =
        (sIdx === 0 && wIdx === 0) || /^[.,;?!]$/.test(raw) ? "" : " "

      return {
        type: "wordNode",
        attrs: {
          "data-sentence-index": sIdx + 1,
          "data-word-index":     wIdx + 1,
          "data-type":           wObj.type,
          class:                 "word-span",
          style:                 `color:${getColorStyle(wObj.type)};cursor:pointer`,
        },
        content: [
          {
            type: "text",
            text: prefix + txt,
            ...(marks.length ? { marks } : {}),
          },
        ],
      }
    }),
  }))

  return {
    type: "doc",
    content: [
      {
        type: "paragraph",
        content: sentenceNodes,
      },
    ],
  }
}

// ─── 6. EditableOutput component ───────────────────────────────────────────
export default function EditableOutput({
  data,
  setSynonymsOptions,
  setSentence,
  setAnchorEl,
  highlightSentence,
  setHighlightSentence,
}) {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({ enter: false }),
      SentenceNode,
      WordNode,
      CursorWatcher,
      EnterHandler,
    ],
    editable: true,
    immediatelyRender: false, // avoid SSR hydration warnings
  })

  // load (or reload) `data` into the editor whenever it changes
  useEffect(() => {
    if (!editor) return
    editor.commands.setContent(formatContent(data))
  }, [editor, data])

  // click-to-synonyms
  useEffect(() => {
    if (!editor) return
    const dom = editor.view.dom
    const onClick = (e) => {
      const el = e.target.closest(".word-span")
      if (!el) return
      const sI = Number(el.getAttribute("data-sentence-index"))
      const wI = Number(el.getAttribute("data-word-index"))
      const wObj = data[sI - 1]?.[wI - 1]
      if (!wObj) return

      setAnchorEl(el)
      setSynonymsOptions({
        synonyms:        wObj.synonyms || [],
        sentenceIndex:  sI,
        wordIndex:      wI,
        showRephraseNav: true,
      })
      setHighlightSentence(sI - 1)
      setSentence(data[sI - 1].map((w) => w.word).join(" "))
    }
    dom.addEventListener("click", onClick)
    return () => dom.removeEventListener("click", onClick)
  }, [editor, data])

  if (!editor) return null
  return <EditorContent editor={editor} />
}

